package nowCoder.algorithm.bit;

/**
 * 1000 0000没有拿来表示-0，而1000 0001也不能拿来直观地表示-1，事实上，-1用1111 1111来表示。
 * 从一个角度来理解，-1大还是-128大，当然是-1大，-1是最大的负整数，所以，无论是字符类型或整数类型，
 * 也无论这个整数是几个字节，从计算结果上来看也是对的：1111 1111-1=1111 1110，表示-2，
 * 这样一直减下去，当减到只身最高位用于表示符号的1以外，其他低位全为0，就是最小的负值，也就是-128
 * @author snow
 *
 */
public class Tools {
	/**java中原始类型中没有无符号类型，如果需要某个宽度的无符号类型，可以使用>>>  无符号右移
	 * 如，需要无符号的short，可以使用int来模拟
	 * 
	 * 0xff，这属于java的字面常量，他已经是int(4个字节，所以相当于是0x0000ffff,所以是正数)了，ff表示为11111111，java对这种字面常量，
	 * 不把他前面的1看做符号位，虽然也是有符号扩展，但是，扩展成的是00...ff.
	 * “数字字面常量”的类型都是int型，而不管他们是几进制，所以“2147483648”、
	 * “0x180000000（十六进制，共33位，所以超过了整数的取值范围）”字面常量是错误的，
	 * 编译时会报超过int的取值范围了，所以要确定以long来表示“2147483648L”、“0x180000000L”。
	 * @param n
	 * @return
	 */
	public int toUnsigned(short n){
		return n & 0x0ffff;
	}
	/**
	 * 如果将一个char数值c转型为一个宽度更宽的整型，并且希望有符号扩展，那么就先将char转型为一个short，它与char上个具有同样的宽度，但是它是有符号的：
		 int i = (short)c; 
		如果将一个byte数值b转型为一个char，并且不希望有符号扩展，那么必须使用一个位掩码来限制它：
		 char c = (char)(b & 0xff);// char c = (char) b;为有符号扩展 
		((byte)0x90 == 0x90)?
		答案是不等的，尽管外表看起来是成立的，但是它却等于false。为了比较byte数值(byte)0x90和int数值0x90，Java
		通过拓宽原生类型将byte提升为int，然后比较这两个int数值。
		因为byte是一个有符号类型，所以这个转换执行的是符号扩展，将负的byte数值提升为了在数字上
		相等的int值（10010000?111111111111111111111111 10010000）。
		在本例中，该转换将(byte)0x90提升为int数值-112，它不等于int数值的0x90，即+144。
		
		解决办法：使用一个屏蔽码来消除符号扩展的影响，从而将byte转型为int。
		  ((byte)0x90 & 0xff)== 0x90 
		  
		String hex = Integer.toHexString(byte[i] & 0xFF);\
		b[i] & 0xFF运算后得出的仍然是个int,那么为何要和 0xFF进行与运算呢?
		直接 Integer.toHexString(b[i]);,将byte强转为int不行吗?答案是不行的
		
		Integer.toHexString的参数是int，如果不进行&0xff，那么当一个byte会转换成int时，
		由于int是32位，而byte只有8位这时会进行补位，例如补码11111111的十进制数为-1转换为int时变为11111111111111111111111111111111好多1啊，呵呵！
		即0xffffffff但是这个数是不对的，这种补位就会造成误差。和0xff相与后，高24比特就会被清0了，结果就对了
		
		至于0xff，这属于java的字面常量，他已经是int了，ff表示为11111111，java对这种字面常量，不把他前面的1看做符号位，虽然也是有符号扩展，但是，扩展成的是00...ff.
	一般在有些编译器重写ff，会把第一位1认为是符号位，所以可以这么写：0x0ff
	 */
}
